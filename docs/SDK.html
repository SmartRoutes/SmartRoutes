<html>
  <head>
    <style type="text/css">
    .todo { color: red;}
    h1 {
      font-size: 36px;
    }
    h2 {
      font-size: 28px;
    }
    h3 {
      font-size: 18px;
    }
    body {
      font: 13px sans-serif;
      line-height: 20px;
    }
    pre, code {
      border: 1px solid #DDD;
      background-color: #F8F8F8;
      border-radius: 3px;
      font: 13px Consolas, monaco, monospace;
    }
    code {
      padding: 0px;
    }
    pre {
      padding: 5px;
    }
    section {
      width: 700px;
      margin: 0 auto;
    }
    div {
      padding-left: 15px;
      border-left: 1px solid #DDD;
      margin-left: 5px;
    }
    </style>
  </head>
  <body>
    <section>
      <h1>SmartRoutes SDK</h1>
      <div>
        <h2>Requirements</h2>
        <div>
          <p>The SmartRoutes SDK is a tool designed for software developers to easily implement public transit routing logic in their own applications. To be clear, this documentation is <i>not</i> intended for the end-user of an application.</p>
          <p>The SmartRoutes SDK cannot be used in all situations. To get started, make sure your situation matches all of these requirements:</p>
          <ol>
            <li>You are developing a .NET 4.5 application.</li>
            <li>You have GTFS data.</li>
            <li>You have destinations, each with a latitude and longitude.</li>
          </ol>
          <h3>You are developing a .NET 4.5 application.</h3>
          <div>
            <p>The SmartRoute graph search algorithm is writtin in C# and can be used by any .NET version 4.5 application. The most popular .NET languages are C# and Visual Basic .NET.</p>
          </div>
          <h3>You have GTFS data.</h3>
          <div>
            <p>GTFS stands for Google Transit Feed Specification. It is a data format made popular by Google to express all sorts of public transportation schedules (e.g. bus schedules and routes). Google has <a href="https://developers.google.com/transit/gtfs/reference">fully documented the specification</a> so that transit organizations can expose their own routes and schedules in a format that Google Maps (and other applications, such as SmartRoutes) can understand. Many transit organizations have already exposed their data in this format. If you are developing an application for your own locality, check the official website of your local transit organization or check the <a href="http://www.gtfs-data-exchange.com/">GTFS Data Exchange</a> website.</p>
            <p>To use GTFS data with SmartRoutes, all you need is the standard ZIP file containing the supported <a href="#" class="todo">GTFS text files</a> on your local hard drive or at a URL.</p>
          </div>
          <h3>You have destinations, each with a latitude and longitude.</h3>
          <div>
            <p>SmartRoutes uses latitude and longitude to place your destinations in a 3 dimensional space: latitude, longitude, and time. A graph is suspended in this space to express the user's passage through time and space. More simply, SmartRoutes needs to know where destinations are so that the proper transit routes can be used! It is recommended that the location's latitude and longitude are precomputed and cached so improve the performance of the searching algorithm.</p>
          </div>
        </div>
        <h2>Using the SmartRoutes SDK</h2>
        <div>
          <p>To use the SmartRoutes SDK in your project, you must follow the following steps:</p>
          <ol>
            <li>Add the SDK to your project.</li>
            <li>Implement the <code>IDestination</code> interface.</li>
            <li>Instantiate GTFS instances.</li>
            <li>Instantiate destination instances.</li>
            <li>Create the graph.</li>
            <li>Construct criteria.</li>
            <li>Search the graph.</li>
            <li>Interpret the results.</li>
          </ol>
          <h3>Add the SDK to your project.</h3>
          <div>
            <p>NuGet is used add the SmartRoutes assemblies to your project. Make sure that <a href="http://nuget.codeplex.com/documentation?title=Getting%20Started">you understand NuGet</a> before getting started.</p>
            <p>The core of the searching logic is in <code>SmartRoutes.Graph.dll</code>, available on NuGet under the name <code>SmartRoutes.Graph</code>. This assembly has a single dependency on the <code>SmartRoutes.Model</code> package. This package will be automatically pulled in by NuGet upon installation of <code>SmartRoutes.Graph</code>.</p>
          </div>
          <h3>Implement the <code>IDestination</code> interface.</h3>
          <div>
            <p>Each of your destinations should be represented by a concrete class that implements the <code>IDestination</code> interface. The full type name for this interface is <code>SmartRoutes.Model.IDestination</code> and is found in the <code>SmartRoutes.Model.dll</code> assembly. This interface itself implements the <code>ILocation</code> interface. In total, this requires you to implement the following read-only (only a <code>get</code> method is required) properties:</p>
            <ul>
              <li><code>double Name { get; }</code> - a string representing the name of the destination, for display only.</li>
              <li><code>double Latitude { get; }</code> - a double representing the latitude of the location.</li>
              <li><code>string Longitude { get; }</code> - a double representing the longitude of the location.</li>
            </ul>
            <p>In addition to these core properties, open hours properties must be implemented for each day of the week. These properties are used to improve the performance of the search algorithm by removing possible destinations if the destination is not open for business, in turn improving the quality of the results. The <code>&lt;day name&gt;Reported</code> boolean indicates whether or not valid open hours are available for this particular destination on that day of the week. If <code>&lt;day name&gt;Reported</code> is <code>true</code>, non-<code>null</code> values for <code>&lt;day name&gt;Begin</code> and <code>&lt;day name&gt;End</code> indicate the open and close times for that destination, respectively.</p>
            <p>If your destination does not have open and close times or this information is not availible, simply return <code>false</code> from all <code>&lt;day name&gt;Reported</code> properties and return <code>null</code> for the open and close times. SmartRoutes will interpret this as a destination that is open at all times of the day.</p>
          </div>
          <h3>Instantiate GTFS instances.</h3>
          <div>
            <p>C# representations of the <a href="https://developers.google.com/transit/gtfs/reference">GTFS entities</a> are provided as part of the <code>SmartRoutes.Model.dll</code> assembly. The following GTFS entities are currently used by SmartRoutes:</p>
            <ul>
              <li><a href="https://developers.google.com/transit/gtfs/reference#routes_fields">route</a> (<code>SmartRoutes.Model.Gtfs.Route</code>)</li>
              <li><a href="https://developers.google.com/transit/gtfs/reference#stops_fields">stop</a> (<code>SmartRoutes.Model.Gtfs.Stop</code>)</li>
              <li><a href="https://developers.google.com/transit/gtfs/reference#stop_times_fields">stop time</a> (<code>SmartRoutes.Model.Gtfs.StopTime</code>)</li>
              <li><a href="https://developers.google.com/transit/gtfs/reference#trips_fields">trip</a> (<code>SmartRoutes.Model.Gtfs.Trip</code>)</li>
            </ul>
            <p>Since the GTFS text files are in an agreed upon format, the SmartRoutes SDK includes an additional assembly used for reading a GTFS zip file and instantiating the associated entities in memory. This parser is available in the <code>SmartRoutes.Reader</code> NuGet package. The parser can be used as follows to parse a ZIP file at an arbitrary location on the local file system into a connect object graph.</p>
            <pre>
// create the parser
var parser = new GtfsCollectionParser(
    new AgencyCsvStreamParser(),
    new RouteCsvStreamParser(),
    new ServiceCsvStreamParser(),
    new ServiceExceptionCsvStreamParser(),
    new ShapePointCsvStreamParser(),
    new StopTimeCsvStreamParser(),
    new StopCsvStreamParser(),
    new TripCsvStreamParser()
);

// create the reader, for instantiating from the file system
var reader = new EntityCollectionReader&lt;GtfsArchive, GtfsCollection&gt;(parser);

// read the ZIP file from the file system
GtfsCollection gtfsObjectGraph = reader.Read(@"C:\my_gtfs_archive.zip", null).Result;</pre>
            <p>Loading from an arbitrary URL is just as easy.</p>
            <pre>
// create the downloader, for instantiating from the web
var downloader = new EntityCollectionDownloader&lt;GtfsArchive, GtfsCollection&gt;(parser);

// read the ZIP file from a URL
GtfsCollection gtfsObjectGraph = downloader.Download(new Uri(
    "https://www.example.com/my_gtfs_archive.zip"), null).Result;</pre>
          </div>
        </div>
      </div>
    </section>
  </body>
</html>